\section{Conclusiones}
\label{sec:conclusiones}

Se nos pidió implementar diferentes programas en lenguaje C++ que resuelvan el mismo problema (Problema de la Mochila 1-0) explicado en el enunciado del trabajo practico, mediante diferentes técnicas algorítmicas.
Para la correcta resolución del mismo utilizamos los diferentes paradigmas algorítmicos vistos en clase, y fuimos capaces de aplicar los conceptos teóricos que los distintos métodos proponen al problema practico de obtener el máximo beneficio al tener una mochila de capacidad dada y un conjunto de pedidos distintos, cada uno con un peso y beneficio asociado.


Durante el desarrollo y la resolución del mismo observamos el gran potencial de los distintos métodos para este tipo de problemas. No obstante, pudimos observar como ciertas técnicas tienen una eficiencia temporal notablemente mejor (programación dinámica, backtracking con podas) sobre el resto de las técnicas (fuerza bruta, meet in the middle, etc) que las hace preferibles. Notamos también que aquellos métodos que proveen una mejor eficiencia temporal suelen conllevar una mayor dificultad a la hora de aplicar y codear la solución. Por lo tanto, aparece cierto $trade-off$ entre dificultad a la hora de aplicar la técnica y, la eficiencia del algoritmo final.
Sin embargo, el conocimiento de los distintos paradigmas algorítmicos nos provee de una posible forma de encarar el problema, sin tener en cuenta su complejidad temporal, cuando en principio podríamos no tener una idea solida de como resolver el mismo. De esta manera, el conocimiento de las mismas resulta en una ventaja a la hora de enfrentar nuevos y mas problemas.


Con respecto a la experimentacion sobre los algoritmos finales, quisimos contrastar el análisis temporal teórico que propusimos sobre cada uno, con su tiempo de ejecución real medido sobre diferentes instancias del problema.
En todos pudimos observar que nuestras cotas superiores propuestas para la complejidad temporal de los algoritmos fueron correctas, es decir, en todos los casos acotaron (de manera ajustada o no) superiormente a los tiempos de ejecución. Esto verifica que realizar este análisis es extremadamente útil y correcto a la hora de tratar de estimar la eficiencia temporal de un algoritmo