\section{Conclusiones}
\label{sec:conclusiones}

Se nos pidió implementar diferentes programas en lenguaje C++ que resuelvan el mismo problema (Problema de la Mochila 1-0) explicado en el enunciado del trabajo practico, mediante diferentes técnicas algorítmicas.
Para la correcta resolución del mismo utilizamos los diferentes paradigmas algorítmicos vistos en clase, y fuimos capaces de aplicar los conceptos teóricos que los distintos métodos proponen al problema practico de obtener el máximo beneficio al tener una mochila de capacidad dada y un conjunto de pedidos distintos, cada uno con un peso y beneficio asociado.


Durante el desarrollo y la resolución del mismo observamos el gran potencial de los distintos métodos para este tipo de problemas. No obstante, pudimos observar como ciertas técnicas tienen una eficiencia temporal notablemente mejor (programación dinámica, backtracking con podas) sobre el resto de las técnicas (fuerza bruta, meet in the middle, etc) que las hace preferibles. Notamos también que aquellos métodos que proveen una mejor eficiencia temporal suelen conllevar una mayor dificultad a la hora de aplicar y codear la solución. Por lo tanto, aparece cierto $trade-off$ entre dificultad a la hora de aplicar la técnica y, la eficiencia del algoritmo final.
Sin embargo, el conocimiento de los distintos paradigmas algorítmicos nos provee de una posible forma de encarar el problema, sin tener en cuenta su complejidad temporal, cuando en principio podríamos no tener una idea solida de como resolver el mismo. De esta manera, el conocimiento de las mismas resulta en una ventaja a la hora de enfrentar nuevos y mas problemas.


Con respecto a la experimentacion sobre los algoritmos finales, quisimos contrastar el análisis temporal teórico que propusimos sobre cada uno, con su tiempo de ejecución real medido sobre diferentes instancias del problema.
Una vez obtenidos los resultados, para lograr un profundo análisis sobre los mismos no solo graficamos ambas funciones, sino que ademas proponemos un gráfico que represente la correlación entre la complejidad teórica propuesta y tiempo real de ejecución del algoritmo. Esto mismo lo realizamos en cada una de las soluciones presentadas.
En todos los casos pudimos observar que nuestras cotas superiores propuestas para la complejidad temporal de los algoritmos fueron correctas, es decir, en todos las situaciones acotaron (de manera ajustada o no) superiormente a los tiempos de ejecución. Esto verifica que realizar este análisis es extremadamente útil y correcto a la hora de tratar de estimar la eficiencia temporal de un algoritmo.


En particular, para el algoritmo de programación dinámica realizamos un gráfico adicional, heatmap, ya que la complejidad temporal propuesta para este algoritmo involucra dos variables del problema (la capacidad de la mochila y la cantidad de pedidos) y este tipo de gráfico exhibe claramente como afectan ambas variables al tiempo de ejecución.
Con respecto al algoritmo de backtracking, también propusimos graficos adicionales para poder comparar el peor y mejor caso del mismo.
En principio decidimos comparar el tiempo de ejecución del mejor caso posible contra el peor caso posible. De esta manera pudimos observar que el peor caso tarda muchísimo mas que el mejor caso posible. Lo cual despertó nuestro interés, y decidimos ver cuan grosera había sido nuestra cota superior para el tiempo de ejecución del algoritmo en su mejor caso y vimos que la misma no resulta para nada ajustada.